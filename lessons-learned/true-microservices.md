# True Microservices

Inevitably, the most popular buzzword (apart from *deep learning*) in today's IT sector is the *microservice architecture*. Suddenly everyone started to develop their next product (or migrate the current ones) based on microservice architecture. I'm not trying to judge anyone. I have little experience with microservices and with IT in overall. Also, I haven't taken the effort to read all the curriculum on microservices. I just want to describe my undestanding of what a microservice truly is. To be honest, I believe that this is the direction where software development should be going, while at the same time this is not a shoot-for-the-moon-land-in-the-star journey, but something that when did wrong is much worse than developing a monolith. 

In this article, I'm going to use two terms on every corner: *microservice architecture*, which refers to a software architecture that's driven by software components that can be referred to as microservices, and the almighty term, *microservice* which is... uhm, something. Basically, I could even stop writing here because I've already made my point: there is no common definition of this term. Instead of coming up with the *nth* definition, I'm going to describe something I'd call a microservice. This is not going to be a strict definition, but something like a guideline.

Based on the current level of my understanding, the part in the word *microservice* we should put the emphasis on is *micro*. This perfectly describes the gist of microservices in an informal way: they're small, concentrated and *atomic*. Small is used here in the context of the number of lines that comprise the source code of the microservice. Concentrated refers to the responsibilities of such an unit: it should contain all the necessary knowledge to perform a specific task. *Atomicity* is closely related to the concentrated nature of microservices. A microservice should contain all the necessary knowledge that's needed for a *SINGLE* task. Not more and not less.

Are these principles enough for developing good-enough microservices? Not at all. A single microservice is like what an ant is to a colony. Powerful on its own, but just a small piece that makes up the whole. Here the colony is the microservice architecture. Just to continue the analogy, in order to make up a functional colony, should the ants know what each of the others are doing? Not at all, again. Microservices should have as little knowledge about it each other as possible. This means that they should be *loosely coupled*. 

How to achieve loose coupling? Manually configuring IP addresses of consumer microservices? Nah. Hiding different types of consumers behind load balancers/proxies/DNS? Still nah. What you're looking for is some kind of service discovery. This way, there's no need for manual configuration. You declare that you depend on some service A, and let the service discovery do its duty. Although this gets rid of the burden of manual configuration, microservices still have to know who the consumer of their output would be. Want to add a new microservice B that would consume the output of microservice A? Guess, you'll have to modify A to send stuff to B too. This sucks.

The Holy Grail of loose coupling is message passing. Microservices receive messages from basically unknown sources and send messages out to the wilderness in hope of someone's listening. This completely eliminates the coupling between the components of your architecture. Of course, direct connections to some components (such as the DB or a job queue) are still needed, but you get the idea. The communication between the microservices is done seldom in the form of messages.

So, are we in Microservice-Nirvana yet? The sad answer is no. Even if you're applying the three principles of small, concetrated and atomic microservices and using message passing for inter-service communication, you can get quite a lot of stuff wrong. The root cause is monolingualism. When designing a new software with a microservice-first approach in mind, one should take into account a particular language might be well-suited for, let's say 80% of the services, but the other 20% could be built in other languages. How would you make it possible for a microservice written in C to talk with another one written in JS? For sure, you need a standardized message format for communication.

Problem solved? Not quite. Although, you now have a polyglot system with loosely coupled microservices hanging around, you're still missing something. For example, let's say that in order to increase the fault tolerance of your system, you decide to add use a circuit breaker. Uh-oh! You cannot use the same circuit breaker library in your microservices, because some of them are written in Scala while others are written in CoffeeScript. Of course, you could use different libraries for each, but that would increase maintenance costs dramatically and would result in slightly different behaviour across the components. Can you guess what the magic word is? Yes, you're right, loose coupling.

Because we want microservices written in different languages, apart from the stuff they're responsible for, be somewhat identical, we have to extract every layer that's possible. And what we arrive at, is the essential business logic. A microservice should not be concerned with message routing, circuit breaking, service discovery and so on. It should only do what it can do best: perform a single business task. That's it. In a true microservice architecture, microservices only contain business logic. Everything else is provided by the environment in a language-agnostic way. Of course, this results in a performance drop, but enables high development speed and minimal coupling.
